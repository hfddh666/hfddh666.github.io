<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="John Doe">







<title>kernel basic | Hexo</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/menu.js"></script>
    










  <meta name="generator" content="Hexo 7.3.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            Frame.
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">Home</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">Archive</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/gallery/">Gallery</a>
              </li> 
                   
          
          
        </ul>
      </nav>
    </div>
  </div>
</div>
<script src="/js/menu.js"></script>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
        </div>
        <div class="post-title">
            
            
                kernel basic
            
            
        </div>
        <span class="post-date">
            Sep 26, 2025
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <h1 id="linux-kernel"><a href="#linux-kernel" class="headerlink" title="linux kernel"></a>linux kernel</h1><h2 id="一-基础知识"><a href="#一-基础知识" class="headerlink" title="一.基础知识"></a>一.基础知识</h2><h3 id="1-操作系统内核"><a href="#1-操作系统内核" class="headerlink" title="1.操作系统内核"></a><strong>1.操作系统内核</strong></h3><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/figure/Kernel_Layout.svg" alt="Kernel_Layout"></p>
<h3 id="2-分级保护环"><a href="#2-分级保护环" class="headerlink" title="2.分级保护环"></a>2.分级保护环</h3><p><strong>通过硬件实现</strong></p>
<p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/figure/ring_model.png" alt="Ring Model"></p>
<p>**用户态：**CPU属于ring 3级别，运行平常写的代码(C&#x2F;C++)</p>
<p>**内核态：**CPU属于ring 0级别</p>
<h3 id="3-状态切换"><a href="#3-状态切换" class="headerlink" title="3.状态切换"></a>3.状态切换</h3><p>CPU 在不同的特权级间进行切换主要有两个途径：</p>
<p>​        <strong>(1)中断与异常</strong>（interrupt &amp; exception）：当 CPU 收到一个中断 &#x2F; 异常时，会切换到 ring0，并                                   根据中断描述符表索引对应的中断处理代码以执行。</p>
<p>​        <strong>(2)特权级相关指令</strong>：当 CPU 运行这些指令时会发生运行状态的改变，例如 iret 指令（ring0-&gt;ring3）或是 sysenter 指令（ring3-&gt;ring0）。</p>
<p>​        基于这些特权级切换的方式，现代操作系统的开发者包装出了系统调用（syscall），作为由 “用户态” 切换到 “内核态” 的入口，从而执行内核代码来完成用户进程所需的一些功能。当用户进程想要请求更高权限的服务时，便需要通过由系统提供的应用接口，使用系统调用以陷入内核态，再由操作系统完成请求。</p>
<h4 id="user-space-to-kernel-space-（系统调用）"><a href="#user-space-to-kernel-space-（系统调用）" class="headerlink" title="user space to kernel space （系统调用）"></a>user space to kernel space （系统调用）</h4><p> 当发生 <code>系统调用</code>，<code>产生异常</code>，<code>外设产生中断</code> 等事件时，会发生用户态到内核态的切换，进入到内核相对应的处理程序中进行处理。 </p>
<p><strong>CPU进入内核态会进行的以下操作：</strong></p>
<ol>
<li><p>通过 <code>swapgs</code> 切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用。</p>
</li>
<li><p>将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp&#x2F;esp。</p>
</li>
<li><p>通过 push 保存各寄存器值，具体的 <a target="_blank" rel="noopener" href="http://elixir.free-electrons.com/linux/v4.12/source/arch/x86/entry/entry_64.S">代码</a> 如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> ENTRY(entry_SYSCALL_64)</span><br><span class="line"> /* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span><br><span class="line"> SWAPGS_UNSAFE_STACK</span><br><span class="line"></span><br><span class="line"> /* 保存栈值，并设置内核栈 */</span><br><span class="line"> movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line"> movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span><br><span class="line">/* Construct struct pt_regs on stack */</span><br><span class="line">pushq  $__USER_DS      /* pt_regs-&gt;ss */</span><br><span class="line">pushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs-&gt;sp */</span><br><span class="line">pushq  %r11             /* pt_regs-&gt;flags */</span><br><span class="line">pushq  $__USER_CS      /* pt_regs-&gt;cs */</span><br><span class="line">pushq  %rcx             /* pt_regs-&gt;ip */</span><br><span class="line">pushq  %rax             /* pt_regs-&gt;orig_ax */</span><br><span class="line">pushq  %rdi             /* pt_regs-&gt;di */</span><br><span class="line">pushq  %rsi             /* pt_regs-&gt;si */</span><br><span class="line">pushq  %rdx             /* pt_regs-&gt;dx */</span><br><span class="line">pushq  %rcx tuichu    /* pt_regs-&gt;cx */</span><br><span class="line">pushq  $-ENOSYS        /* pt_regs-&gt;ax */</span><br><span class="line">pushq  %r8              /* pt_regs-&gt;r8 */</span><br><span class="line">pushq  %r9              /* pt_regs-&gt;r9 */</span><br><span class="line">pushq  %r10             /* pt_regs-&gt;r10 */</span><br><span class="line">pushq  %r11             /* pt_regs-&gt;r11 */</span><br><span class="line">sub $(6*8), %rsp      /* pt_regs-&gt;bp, bx, r12-15 not saved */</span><br></pre></td></tr></table></figure>

<p>4.通过汇编指令判断是否为 <code>x32_abi</code>。</p>
<p>5.通过系统调用号，跳到全局变量 <code>sys_call_table</code> 相应位置继续执行系统调用。</p>
</li>
</ol>
<h4 id="kernel-space-to-user-space"><a href="#kernel-space-to-user-space" class="headerlink" title="kernel space to user space"></a>kernel space to user space</h4><p>退出时，流程如下：</p>
<ol>
<li>通过 <code>swapgs</code> 恢复 GS 值。</li>
<li>通过 <code>sysretq</code> 或者 <code>iretq</code> 恢复到用户控件继续执行。如果使用 <code>iretq</code> 还需要给出用户空间的一些信息（CS, eflags&#x2F;rflags, esp&#x2F;rsp 等）。</li>
</ol>
<h3 id="4-虚拟内存空间"><a href="#4-虚拟内存空间" class="headerlink" title="4.虚拟内存空间"></a>4.虚拟内存空间</h3><p><strong>32位</strong></p>
<p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/figure/mm_layout_32.png" alt="32 位系统内存布局"></p>
<p><strong>64位</strong></p>
<p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/figure/mm_layout_64.png" alt="64 位系统内存布局"></p>
<h3 id="5-进程权限管理"><a href="#5-进程权限管理" class="headerlink" title="5.进程权限管理"></a>5.进程权限管理</h3><h4 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h4><p>在内核中用task_struct表示一个进程</p>
<p>一个进程描述符表示：由多个struct组成</p>
<p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/figure/task_struct.png" alt="task_struct"></p>
<h4 id="进程权限凭证"><a href="#进程权限凭证" class="headerlink" title="进程权限凭证"></a>进程权限凭证</h4><p>task_struct源码存在一个cred结构体，cred用于管理一个进程的权限</p>
<p>一个 cred 结构体中记载了一个进程四种不同的用户 ID，在通常情况下这几个 ID 应当都是相同的：</p>
<ul>
<li>真实用户 ID（real UID）：标识一个进程启动时的用户 ID</li>
<li>保存用户 ID（saved UID）：标识一个进程最初的有效用户 ID</li>
<li>有效用户 ID（effective UID）：标识一个进程正在运行时所属的用户 ID，一个进程在运行途中是可以改变自己所属用户的，因而权限机制也是通过有效用户 ID 进行认证的，内核通过 euid 来进行特权判断；为了防止用户一直使用高权限，当任务完成之后，euid 会与 suid 进行交换，恢复进程的有效权限</li>
<li>文件系统用户 ID（UID for VFS ops）：标识一个进程创建文件时进行标识的用户 ID</li>
</ul>
<p>用户组 ID 同样分为四个：真实组 ID、保存组 ID、有效组 ID、文件系统组 ID，与用户 ID 是类似的，这里便不再赘叙。</p>
<h4 id="进程权限改变"><a href="#进程权限改变" class="headerlink" title="进程权限改变"></a>进程权限改变</h4><p>前面我们讲到，一个进程的权限是由位于内核空间的 <code>cred</code> 结构体进行管理的，那么我们不难想到：只要改变一个进程的 <code>cred</code> 结构体，就能改变其执行权限。</p>
<p>在内核空间有如下两个函数，都位于 <code>kernel/cred.c</code> 中：</p>
<ul>
<li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的 cred 结构体，并返回一个新的 cred 结构体，需要注意的是 daemon 参数应为有效的进程描述符地址。</li>
<li><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的 cred 结构体应用到进程。</li>
</ul>
<h3 id="6-Loadable-Kernel-Modules-LKMs"><a href="#6-Loadable-Kernel-Modules-LKMs" class="headerlink" title="6.Loadable Kernel Modules(LKMs)"></a>6.Loadable Kernel Modules(LKMs)</h3><p> Linux Kernel 采用的是宏内核(但其本身是一个单内核)架构，一切的系统服务都需要由内核来提供， </p>
<p>LKMS 位于内核空间的 LKMs </p>
<p>常见的 LKMs 包括：</p>
<ul>
<li>驱动程序（Device drivers）<ul>
<li>设备驱动</li>
<li>文件系统驱动</li>
<li>…</li>
</ul>
</li>
<li>内核扩展模块 (modules)</li>
</ul>
<p> LKMs 的文件格式和用户态的可执行程序相同，Linux 下为 ELF，Windows 下为 exe&#x2F;dll，mac 下为 MACH-O，因此我们可以用 IDA 等工具来分析内核模块。 </p>
<p>模块可以被单独编译，但不能被单独运行</p>
<h4 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h4><ul>
<li><strong>insmod</strong>: 讲指定模块加载到内核中</li>
<li><strong>rmmod</strong>: 从内核中卸载指定模块</li>
<li><strong>lsmod</strong>: 列出已经加载的模块</li>
<li><strong>modprobe</strong>: 添加或删除模块，modprobe 在加载模块时会查找依赖关系</li>
</ul>
<h3 id="7-内核交互"><a href="#7-内核交互" class="headerlink" title="7.内核交互"></a>7.内核交互</h3><h4 id="系统调用：ioctl（可以直接寻址）"><a href="#系统调用：ioctl（可以直接寻址）" class="headerlink" title="系统调用：ioctl（可以直接寻址）"></a>系统调用：ioctl（可以直接寻址）</h4><p>在 <code>*NIX</code> 中一切都可以被视为文件，因而一切都可以以访问文件的方式进行操作，为了方便，Linux 定义了系统调用 <code>ioctl</code> 供进程与设备之间进行通信。</p>
<p><code>ioctl</code> 是一个专用于设备输入输出操作的一个系统调用，其调用方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int ioctl(int fd, unsigned long request, ...)</span><br></pre></td></tr></table></figure>

<p>其第一个参数为打开设备 (open) 返回的 <a target="_blank" rel="noopener" href="http://m4x.fun/post/play-with-file-descriptor-1/">文件描述符</a>，第二个参数为用户程序对设备的控制命令，再后边的参数则是一些补充参数，与设备有关。</p>
<p>对于一个提供了 ioctl 通信方式的设备而言，我们可以通过其文件描述符、使用不同的请求码及其他请求参数通过 ioctl 系统调用完成不同的对设备的 I&#x2F;O 操作。</p>
<h3 id="8-常见内核态函数"><a href="#8-常见内核态函数" class="headerlink" title="8.常见内核态函数"></a>8.常见内核态函数</h3><p>常用的功能函数如下：</p>
<ul>
<li>printf() -&gt; <strong>printk()</strong>，但需要注意的是 printk() 不一定会把内容显示到终端上，但一定在内核缓冲区里，可以通过 <code>dmesg</code> 查看效果</li>
<li>memcpy() -&gt;copy_from_user()&#x2F;copy_to_user()<ul>
<li>copy_from_user() 实现了将用户空间的数据传送到内核空间</li>
<li>copy_to_user() 实现了将内核空间的数据传送到用户空间</li>
</ul>
</li>
<li>malloc() -&gt; <strong>kmalloc()</strong>，内核态的内存分配函数，和 malloc() 相似，但使用的是 <code>slab/slub 分配器</code></li>
<li>free() -&gt; <strong>kfree()</strong>，同 kmalloc()</li>
</ul>
<p>此外，<code>kernel 管理进程，因此 kernel 也记录了进程的权限</code>。kernel 中有两个可以方便的改变权限的函数：</p>
<ul>
<li><strong>int commit_creds(struct cred *new)</strong></li>
<li><strong>struct cred* prepare_kernel_cred(struct task_struct* daemon)</strong></li>
</ul>
<p>从函数名也可以看出，执行 <code>commit_creds(prepare_kernel_cred(&amp;init_task))</code> 即可获得 root 权限，即拷贝 init 进程的 cred 作为当前进程的新的 credentials。</p>
<p>执行 <code>commit_creds(prepare_kernel_cred(&amp;init_task))</code> 也是最常用的提权手段，这些函数与变量的地址都可以在 <code>/proc/kallsyms</code> 中查看（较老的内核版本中是 <code>/proc/ksyms</code>），该文件的内容通常需要 root 权限才能正确查看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cat /proc/kallsyms | grep &quot;T commit_creds&quot;</span><br><span class="line">ffffffffbb11ab20 T commit_creds</span><br><span class="line">$ sudo cat /proc/kallsyms | grep &quot;T prepare_kernel_cred&quot;</span><br><span class="line">ffffffffbb11b080 T prepare_kernel_cred</span><br><span class="line">$ sudo cat /proc/kallsyms | grep &quot;D init_cred&quot;</span><br><span class="line">ffffffffbce58840 D init_cred</span><br></pre></td></tr></table></figure>

<h3 id="9-保护机制"><a href="#9-保护机制" class="headerlink" title="9.保护机制"></a>9.保护机制</h3><h4 id="通用保护"><a href="#通用保护" class="headerlink" title="通用保护"></a>通用保护</h4><p><strong>kaslr</strong>：内存地址随机化，加个偏移值； 在未开启 KASLR 保护机制时，内核代码段的基址为 <code>0xffffffff81000000</code> ，direct mapping area 的基址为 <code>0xffff888000000000</code>。 </p>
<p><strong>内存布局： <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.3/source/Documentation/x86/x86_64/mm.rst">这里</a></strong> </p>
<p>*<strong>fgaslr</strong></p>
<p><strong>canary</strong></p>
<p><strong>smap|smep</strong>：SMAP 即<code>管理模式访问保护</code>，SMEP 即<code>管理模式执行保护</code>，这两种保护通常是同时开启的，用以阻止<strong>内核空间直接访问 &#x2F; 执行用户空间的数据</strong>，完全地将内核空间与用户空间相分隔开，用以防范 ret2usr（return-to-user，将内核空间的指令指针重定向至用户空间上构造好的提权代码）攻击。</p>
<p>SMEP 保护的绕过有以下两种方式：</p>
<ul>
<li>利用内核线性映射区对物理地址空间的完整映射，找到用户空间对应页框的内核空间地址，利用该内核地址完成对用户空间的访问（即一个内核空间地址与一个用户空间地址映射到了同一个页框上），这种攻击手法称为 ret2dir 。</li>
<li>Intel 下系统根据 CR4 控制寄存器的第 20 位标识是否开启 SMEP 保护（1 为开启，0 为关闭），若是能够通过 kernel ROP 改变 CR4 寄存器的值便能够关闭 SMEP 保护，完成 SMEP-bypass，接下来就能够重新进行 ret2usr，<strong>但对于开启了 KPTI 的内核而言，内核页表的用户地址空间无执行权限，这使得 ret2usr 彻底成为过去式</strong> 。</li>
</ul>
<p><strong>kpie</strong>:</p>
<p> <strong>在这两张页表上都有着对用户内存空间的完整映射，但在用户页表中只映射了少量的内核代码（例如系统调用入口点、中断处理等），而只有在内核页表中才有着对内核内存空间的完整映射，但两张页表都有着对用户内存空间的完整映射</strong> </p>
<p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/figure/kpti.png" alt="KPTI"></p>
<p> KPTI 同时还令内核页表中属于用户地址空间的部分不再拥有执行权限，这使得 ret2usr 彻底成为过去式。 </p>
<h4 id="堆保护"><a href="#堆保护" class="headerlink" title="堆保护"></a>堆保护</h4><p><strong>1.Hardened Usercopy</strong></p>
<p>hardened usercopy 是用以在用户空间与内核空间之间拷贝数据时进行越界检查的一种防护机制，<strong>主要检查拷贝过程中对内核空间中数据的读写是否会越界</strong>：</p>
<ul>
<li>读取的数据长度是否超出源 object 范围。</li>
<li>写入的数据长度是否超出目的 object 范围。</li>
</ul>
<p>这一保护被用于 <code>copy_to_user()</code> 与 <code>copy_from_user()</code> 等数据交换 API 中，不过这种保护 <em>不适用于内核空间内的数据拷贝</em> ，这也是目前主流的绕过手段。</p>
<p><strong>2.Hardened freelist</strong></p>
<p>类似于 glibc 2.32 版本引入的保护，在开启这种保护之前，slub 中的 free object 的 next 指针直接存放着 next free object 的地址，攻击者可以通过读取 freelist 泄露出内核线性映射区的地址，在开启了该保护之后 free object 的 next 指针存放的是由以下三个值进行异或操作后的值：</p>
<ul>
<li>当前 free object 的地址。</li>
<li>下一个 free object 的地址。</li>
<li>由 kmem_cache 指定的一个 random 值。</li>
</ul>
<p>攻击者至少需要获取到第一与第三个值才能篡改 freelist，这无疑为对 freelist 的直接利用增添不少难度。</p>
<p><strong>3.Random freelist</strong></p>
<p> slub allocator 刚从 buddy system 拿到新 slub 的时候，运行时 freelist 的构成仍遵循 LIFO。 </p>
<p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/figure/freelist_random.png" alt="Random freelist"></p>
<h2 id="二-内核源码下载与编译"><a href="#二-内核源码下载与编译" class="headerlink" title="二.内核源码下载与编译"></a>二.内核源码下载与编译</h2><h3 id="1-下载内核源码"><a href="#1-下载内核源码" class="headerlink" title="1.下载内核源码"></a>1.下载内核源码</h3><p>根据 <a target="_blank" rel="noopener" href="https://www.kernel.org/category/releases.html">Archive kernel releases</a>，我们可以知道内核主要有以下几种类别：</p>
<ul>
<li>Prepatch (RC) ：主线内核的预发布版本，包含了最新的待测试的内核特性，由 Linus Torvalds 维护。</li>
<li>Mainline：主线内核版本，RC 版本的新特性经过测试后便会合并到主线，每 9～10 周发一个版本，由 Linus Torvalds 维护。</li>
<li>Stable：主线内核发布后便会变为 Stable 状态，其仅会被 stable kernel 维护者从主线树后向移植一些漏洞修复，直到下个内核版本释出。Stable kernel 根据需要进行更新，通常是一周一次。</li>
<li>Longterm：部分内核版本会被选作长期支持版（LTS），相比起 Stable 内核有着更久的支持时长，通常仅会被后向移植重要的漏洞修复，且更新周期较慢（尤其是对于更老的版本）。</li>
</ul>
<p><strong>下载内核</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v6.x/linux-6.12.16.tar.xz </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unxz ./linux-6.12.16.tar.xz </span><br></pre></td></tr></table></figure>

<p><strong>验证签名</strong></p>
<p> 导入 Linus Torvalds 和 Greg Kroah-Hartman 的公钥 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg2 --locate-keys torvalds@kernel.org gregkh@kernel.org </span><br></pre></td></tr></table></figure>

<p> 下载内核签名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v6.x/linux-6.12.16.tar.sign</span><br></pre></td></tr></table></figure>

<p>校验</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg2 --verify linux-6.12.16.tar.sign </span><br></pre></td></tr></table></figure>

<p>结果会有warning，因为导入的公钥没有可信签名，那我们就让其可信</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg2 --tofu-policy good 38DBBDC86092693E </span><br></pre></td></tr></table></figure>

<p>重新验证</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpg2 --trust-model tofu --verify ./linux-6.12.16.tar.sign </span><br><span class="line"></span><br><span class="line">tar -xf linux-6.12.16.tar</span><br></pre></td></tr></table></figure>

<h3 id="2-配置编译选项"><a href="#2-配置编译选项" class="headerlink" title="2.配置编译选项"></a>2.配置编译选项</h3><p>首先我们要先进入源码目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls  一下找到源码然后</span><br><span class="line">cd ~/文件名 #一般是linux 6-12之类的</span><br></pre></td></tr></table></figure>

<p>这样我们就进入了文件源码目录</p>
<p>动态生成编译配置系统</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig </span><br></pre></td></tr></table></figure>

<p>根据当前系统进行微调</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make defconfig</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make localyesconfig # 将驱动编译到内核当中</span><br><span class="line">make allyesconfig # 将驱动编译到内核当中</span><br></pre></td></tr></table></figure>

<h3 id="3-调试相关选项"><a href="#3-调试相关选项" class="headerlink" title="3.调试相关选项"></a>3.调试相关选项</h3><p>依次进入到 Kernel hacking -&gt; Compile-time checks and compiler options，然后勾选如下选项 <code>Compile the kernel with debug info</code> ，以便于调试。这通常是默认开启的。</p>
<p>如果要使用 kgdb 调试内核，则需要选中 <code>KGDB: kernel debugger</code>，并选中 KGDB 下的所有选项。</p>
<h3 id="4-编译内核"><a href="#4-编译内核" class="headerlink" title="4.编译内核"></a>4.编译内核</h3><p>还是要在内核源码目录中进行</p>
<p>获得的是压缩后的内核镜像文件 <code>bzImage</code> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make bzImage   #狗屎啊，怎么要这么久</span><br></pre></td></tr></table></figure>

<p> <code>-j</code> 参数指定了同时进行编译的内核数量，<code>(nproc)</code> 变量则通常代表你所使用的机器所拥有的硬件线程数： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j(nproc) bzImage</span><br></pre></td></tr></table></figure>

<p>最后，当终端出现如下信息时，说明编译完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kernel: arch/x86/boot/bzImage is ready  (#1)</span><br></pre></td></tr></table></figure>

<p>产物中的两个文件：</p>
<ul>
<li><code>vmlinux</code>：编译生成的 ELF 格式的原始内核镜像文件，通常位于源码根目录下。</li>
<li><code>bzImage</code>：前者进行压缩后的内核镜像文件，通常位于 <code>arch/架构/boot/bzImage</code> （注意对于 x86-64 而言仍是 <code>x86</code> 目录）。</li>
</ul>
<h2 id="四-搭建内核运行环境"><a href="#四-搭建内核运行环境" class="headerlink" title="四.搭建内核运行环境"></a>四.搭建内核运行环境</h2><h3 id="1-获取内核镜像文件（make-j-nproc-bzImage"><a href="#1-获取内核镜像文件（make-j-nproc-bzImage" class="headerlink" title="1.获取内核镜像文件（make -j$(nproc) bzImage)"></a>1.获取内核镜像文件（make -j$(nproc) bzImage)</h3><h3 id="2-使用-BusyBox-搭建基本的文件系统"><a href="#2-使用-BusyBox-搭建基本的文件系统" class="headerlink" title="2.使用 BusyBox 搭建基本的文件系统"></a>2.使用 BusyBox 搭建基本的文件系统</h3><p>busybox是一个包含许多命令的软件、</p>
<p>下载busybox源码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://busybox.net/downloads/busybox-1.36.0.tar.bz2 </span><br><span class="line">tar -jxvf busybox-1.36.0.tar.bz2</span><br></pre></td></tr></table></figure>

<p>编译busybox（在busybox目录下进行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig </span><br><span class="line">make -j$(nproc)</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="配置文件系统（在-install目录下进行）"><a href="#配置文件系统（在-install目录下进行）" class="headerlink" title="配置文件系统（在_install目录下进行）"></a><strong>配置文件系统（在_install目录下进行）</strong></h4><p>创建文件系统结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd _install </span><br><span class="line">$ mkdir -pv &#123;bin,sbin,etc,proc,sys,dev,home/ctf,root,tmp,lib64,lib/x86_64-linux-gnu,usr/&#123;bin,sbin&#125;&#125; </span><br><span class="line">$ touch etc/inittab </span><br><span class="line">$ mkdir etc/init.d </span><br><span class="line">$ touch etc/init.d/rcS </span><br><span class="line">$ chmod +x ./etc/init.d/rcS </span><br></pre></td></tr></table></figure>

<p> 在 <code>./etc/inittab</code> 中写入如下内容： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS ::askfirst:/bin/login ::ctrlaltdel:/sbin/reboot ::shutdown:/sbin/swapoff -a ::shutdown:/bin/umount -a -r ::restart:/sbin/init </span><br></pre></td></tr></table></figure>

<p> etc&#x2F;init.d&#x2F;rcS ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">\#!/bin/sh </span><br><span class="line">chown -R root:root / </span><br><span class="line">chmod 700 /root </span><br><span class="line">chown -R ctf:ctf /home/ctf </span><br><span class="line">mount -t proc none /proc </span><br><span class="line">mount -t sysfs none /sys </span><br><span class="line">mount -t tmpfs tmpfs /tmp </span><br><span class="line">mkdir /dev/pts </span><br><span class="line">mount -t devpts devpts /dev/pts </span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict </span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict </span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot; </span><br><span class="line">cd /home/ctf </span><br><span class="line">su ctf -c sh </span><br><span class="line">poweroff -d 0  -f </span><br></pre></td></tr></table></figure>

<p>然后为这个脚本添加可执行权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./etc/init.d/rcS </span><br></pre></td></tr></table></figure>

<p> 接下来配置用户组相关权限，在这里建立了两个用户组 <code>root</code> 和 <code>ctf</code> ，以及两个用户 <code>root</code> 和 <code>ctf</code>，并配置了一条文件系统挂载项： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;root:x:0:0:root:/root:/bin/sh&quot; &gt; etc/passwd </span><br><span class="line">$ echo &quot;ctf:x:1000:1000:ctf:/home/ctf:/bin/sh&quot; &gt;&gt; etc/passwd </span><br><span class="line">$ echo &quot;root:x:0:&quot; &gt; etc/group </span><br><span class="line">$ echo &quot;ctf:x:1000:&quot; &gt;&gt; etc/group </span><br><span class="line">$ echo &quot;none /dev/pts devpts gid=5,mode=620 0 0&quot; &gt; etc/fstab </span><br></pre></td></tr></table></figure>

<h4 id="打包文件系统（在busybox目录下进行）"><a href="#打包文件系统（在busybox目录下进行）" class="headerlink" title="打包文件系统（在busybox目录下进行）"></a>打包文件系统（在busybox目录下进行）</h4><p><strong>qcow2格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create -f qcow2 rootfs.qcow2 8M  #创建一个qcow2格式的镜像文件</span><br><span class="line">sudo qemu-nbd -c /dev/nbd0 ./rootfs.qcow2 #挂载为网络设备</span><br><span class="line">sudo mkfs.ext4 /dev/nbd0 #格式化为自己想要的文件系统，例如最常用的 ext4</span><br><span class="line">sudo mount /dev/nbd0 /mnt #常规挂载</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后把前面我们构建的文件系统内容拷贝进去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp -auv _install/* /mnt</span><br><span class="line">$ sudo chown -R root:root /mnt/</span><br><span class="line">$ sudo chmod 700 /mnt/root</span><br><span class="line">$ sudo chown -R 1000:1000 /mnt/home/ctf/</span><br></pre></td></tr></table></figure>

<p>最后常规卸载并解绑 nbd 即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo umount /mnt</span><br><span class="line">$ sync</span><br><span class="line">$ sudo qemu-nbd -d /dev/nbd0</span><br></pre></td></tr></table></figure>

<h3 id="3-启动内核"><a href="#3-启动内核" class="headerlink" title="3.启动内核"></a>3.启动内核</h3><p>将bzImage和rootfs.qcow2，kernel.sh放在同一个文件夹，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kernel.sh</span><br></pre></td></tr></table></figure>

<p>kernel.sh内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\#!/bin/sh </span><br><span class="line">qemu-system-x86_64 \    </span><br><span class="line">    -m 128M \    </span><br><span class="line">    -kernel ./bzImage \    </span><br><span class="line">    -hda ./rootfs.qcow2 \    </span><br><span class="line">    -monitor /dev/null \    </span><br><span class="line">    -append &quot;root=/dev/sda rw rdinit=/sbin/init console=ttyS0 oops=panic panic=1 loglevel=3 quiet kaslr&quot; \    </span><br><span class="line">    -cpu kvm64,+smep \    </span><br><span class="line">    -smp cores=2,threads=1 \   </span><br><span class="line">    -nographic \    </span><br><span class="line">    -snapshot \    </span><br><span class="line">    -s </span><br></pre></td></tr></table></figure>

<p>各参数说明如下，详细说明可以参照 QEMU 的官方文档：</p>
<ul>
<li><p><code>-m</code>：虚拟机内存大小。</p>
</li>
<li><p><code>-kernel</code>：内核镜像路径。</p>
</li>
<li><p><code>-hda</code>：文件系统路径，我们将 qcow2 镜像挂载为一个真正的硬盘设备，优点在于更贴近真实环境。</p>
</li>
<li><p><code>-monitor</code>：将监视器重定向到主机设备 <code>/dev/null</code>，这里重定向至 null 主要是防止 CTF 中被人通过监视器直接拿 flag。</p>
</li>
<li><pre><code>-append
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：内核启动参数选项</span><br><span class="line"></span><br><span class="line">  - `root=/dev/sda rw`：该参数设定了根文件系统所在设备，因为我们使用 `-hda` 将其挂载为一个 SATA 硬盘，而 Linux 中第一个 SATA 硬盘的路径为 `/dev/sda` ，因此我们将根文件系统路径指向设备路径，并通过 `rw` 标识来给予可读写权限。</span><br><span class="line">  - `kaslr`：开启内核地址随机化，你也可以改为 `nokaslr` 进行关闭以方便我们进行调试。</span><br><span class="line">  - `rdinit`：指定初始启动进程，这里我们指定了 `/sbin/init` 作为初始进程，根据我们前面的配置其会默认以 `/etc/init.d/rcS` 作为启动脚本。</span><br><span class="line">  - `loglevel=3` &amp; `quiet`：不输出 log。</span><br><span class="line">  - `console=ttyS0`：指定终端为 `/dev/ttyS0`，这样一启动就能进入终端界面。</span><br><span class="line"></span><br><span class="line">- `-cpu`：设置 CPU 选项，在这里开启了 smep 保护。</span><br><span class="line"></span><br><span class="line">- `-smp`：设置对称多处理器配置，这里设置了两个核心，每个核心一个线程。</span><br><span class="line"></span><br><span class="line">- `-nographic`：不提供图形化界面，此时内核仅有串口输出，输出内容会被 QEMU 重定向至我们的终端。</span><br><span class="line"></span><br><span class="line">- `-snapshot`：使用快照的方式启动，这样在虚拟机当中对文件系统的修改不会 “落盘”。</span><br><span class="line"></span><br><span class="line">- `-s`：相当于`-gdb tcp::1234`的简写（也可以直接这么写），后续我们可以通过 gdb 连接本地端口进行调试。</span><br><span class="line"></span><br><span class="line">启动后效果：![1756207588927](C:\Users\shizihang\AppData\Roaming\Typora\typora-user-images\1756207588927.png)</span><br><span class="line"></span><br><span class="line">### 4.加载驱动</span><br><span class="line"></span><br><span class="line">将生成的.ko文件放在一起的文件夹，然后在init.d中添加insmod命令添加</span><br><span class="line"></span><br></pre></td></tr></table></figure>
chown -R root:root / 
chmod 700 /root 
chown -R ctf:ctf /home/ctf 
mount -t proc none /proc 
mount -t sysfs none /sys 
mount -t tmpfs tmpfs /tmp 
mkdir /dev/pts 
mount -t devpts devpts /dev/pts 
echo 1 &gt; /proc/sys/kernel/dmesg_restrict 
echo 1 &gt; /proc/sys/kernel/kptr_restrict 
insmod /root/a3kmod.ko 
echo -e &quot;\nBoot took $(cut -d&#39; &#39; -f1 /proc/uptime) seconds\n&quot; 
cd /root 
su root -c sh 
poweroff -d 0  -f
</code></pre>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> 启动内核后，我们可以使用 dmesg 查看输出，可以看到确实加载了对应的 ko </span><br><span class="line"></span><br><span class="line">### 5.调试分析</span><br><span class="line"></span><br><span class="line">init脚本：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> su root -c sh  #以root用户启动<br> su ctf -c sh  #以使用者启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">内核关闭随机化：将kaslr改为nokaslr</span><br><span class="line"></span><br><span class="line">#### 基本操作</span><br><span class="line"></span><br><span class="line"> 1.获取特定内核符号信息</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>cat &#x2F;proc&#x2F;kallsyms | grep prepare_kernel_cred </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.查看klmd</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>lsmod</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3.读取内核模块信息</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> cat &#x2F;sys&#x2F;module&#x2F;a3kmod&#x2F;sections&#x2F;.text<br> cat &#x2F;sys&#x2F;module&#x2F;a3kmod&#x2F;sections&#x2F;.data </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 启动调试</span><br><span class="line"></span><br><span class="line"> 在启动参数中添加 `-gdb dev` 来启动调试服务 </span><br><span class="line"></span><br><span class="line"> 最常见的操作为在一个端口监听一个 tcp 连接。 QEMU 同时提供了一个简写的方式 `-s`，表示 `-gdb tcp::1234`，即在 1234 端口开启一个 gdbserver。 </span><br><span class="line"></span><br><span class="line"> 以调试模式启动内核后，我们就可以在另外一个终端内使用如下命令来连接到对应的 gdbserver，开始调试 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> gdb -q -ex “target remote localhost:1234” </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">启动内核后，我们可以在 gdb 中使用 `add-symbol-file` 字命令来添加符号信息，并使用 `-s 段名称 段地址` 格式的附加参数指定各个段在内存中的加载地址，例如： </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> add-symbol-file .&#x2F;test_kmod&#x2F;src&#x2F;a3kmod.ko -s .text 0xffffffffc008f000 -s .data 0xffffffffc0091038 -s .bss 0xffffffffc0091540 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 五.system.map</span><br><span class="line"></span><br><span class="line">当我们获得的 vmlinux 是 stripped 时就需要 System.map 来帮助我们调试。 `System.map` 文件是一个纯文本文件，每一行包含三个字段：</span><br><span class="line"></span><br><span class="line">符号地址（内存地址） 符号类型（例如：函数、变量）如果为小写，则符号为本地符号; 如果大写，符号为全局（外部）。 符号名（标识符）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> └─$ head System.map<br> 0000000000000000 A VDSO32_PRELINK<br> 0000000000000000 D __per_cpu_start<br> 0000000000000000 D per_cpu__irq_stack_union  0000000000000000 A xen_irq_disable_direct_reloc 0000000000000000 A xen_save_fl_direct_reloc<br> 0000000000000040 A VDSO32_vsyscall_eh_frame_size  00000000000001e7 A kexec_control_code_size<br> 00000000000001f0 A VDSO32_NOTE_MASK<br> 0000000000000400 A VDSO32_sigreturn<br> 0000000000000410 A VDSO32_rt_sigreturn </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">启动脚本：</span><br><span class="line"></span><br><span class="line">先将vmlinux文件放入ida中，再用shift+F12打开脚本命令窗口，黏贴如下代码，运行后，选择正确的system.map文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> import idaapi</p>
<p>def load_system_map(file_path):<br>    with open(file_path, “r”) as f:<br>        for line in f:<br>            parts &#x3D; line.split()<br>            if len(parts) &lt; 3:<br>                continue</p>
<pre><code>        addr = int(parts[0], 16)
        symbol_type = parts[1]
        symbol_name = parts[2]

        # if symbol_type in [&#39;T&#39;, &#39;t&#39;, &#39;D&#39;, &#39;d&#39;, &#39;B&#39;, &#39;b&#39;]:     #如果符号表太大，可以针对性添加
        if not idaapi.add_entry(addr, addr, symbol_name, 0):
            print(f&quot;Failed to add symbol: &#123;symbol_name&#125; at &#123;hex(addr)&#125;&quot;)
        else:
            print(f&quot;Added symbol: &#123;symbol_name&#125; at &#123;hex(addr)&#125;&quot;)
</code></pre>
<p>system_map_path &#x3D; idaapi.ask_file(0, “*.map”, “Select System.map file”)<br>if system_map_path:<br>    load_system_map(system_map_path) #！！！路径在这<br>else:<br>    print(“No file selected”)</p>
<pre><code>
</code></pre>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
                <div class="icon arrow-left"></div>
                <div class="post-link">
                    <a href="/2025/09/26/%E6%8C%87%E5%8D%97/">Prev</a>
                </div>
            
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2025/09/26/qwb2018/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

    
    

  </body>
</html>
